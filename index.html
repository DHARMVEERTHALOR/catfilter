<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cat Face Filter - WebView Friendly</title>
<style>
body { margin:0; background:#000; display:flex; justify-content:center; align-items:center; height:100vh; overflow:hidden; }
canvas { position:absolute; top:0; left:0; }
#controls { position:fixed; bottom:20px; left:50%; transform:translateX(-50%); display:flex; gap:10px; z-index:1000; }
button { padding:10px 16px; font-size:15px; border:none; border-radius:10px; background:#ff8fb3; color:#fff; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,0.4); }
button:disabled { opacity:0.5; cursor:default; }
#startOverlay {
    position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.2);
    display:flex; justify-content:center; align-items:center; z-index:1000; cursor:pointer; font-size:20px; color:#fff;
}
</style>
</head>
<body>

<video id="video" autoplay playsinline muted style="display:none;"></video>
<canvas id="canvas"></canvas>

<div id="controls">
  <button id="start" disabled>Start/Pause</button>
  <button id="stop" disabled>Stop & Download</button>
</div>

<div id="startOverlay">Tap anywhere to start camera</div>

<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js" defer></script>

<script>
const video=document.getElementById('video');
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
const overlay=document.getElementById('startOverlay');

let stream, animationFrame, recording=false, mediaRecorder, recordedChunks=[];
let audioCtx, analyser, dataArray;
let blinkProgress=1, lastBlink=Date.now(), nextBlinkIn=2000+Math.random()*3000;
let prevNoseX=0, prevNoseY=0;

// Images
const catMask = new Image(); catMask.src='cat-mask.png';
const mouthFrames=[]; for(let i=1;i<=3;i++){ const img=new Image(); img.src=`mouth${i}.png`; mouthFrames.push(img); }
const ears=new Image(); ears.src='ears.png';
const eyes=new Image(); eyes.src='eyes.png';

// lerp
function lerp(a,b,t){ return a + (b-a)*t; }
function resizeCanvas(){ canvas.width=video.videoWidth||480; canvas.height=video.videoHeight||854; }
window.addEventListener('resize', resizeCanvas);

// Load models
async function loadModels(){
    await Promise.all([
        faceapi.nets.ssdMobilenetv1.loadFromUri('/models'),
        faceapi.nets.faceLandmark68Net.loadFromUri('/models'),
        faceapi.nets.faceExpressionNet.loadFromUri('/models')
    ]);
}
loadModels();

// Start camera + audio after user tap
async function startCameraAndAudio(){
    try{
        stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'user', width:480, height:854}, audio:true});
        video.srcObject=stream;
        await video.play();
        resizeCanvas();

        mediaRecorder=new MediaRecorder(stream,{mimeType:'video/webm'});
        mediaRecorder.ondataavailable=e=>{ if(e.data.size>0) recordedChunks.push(e.data); };
        mediaRecorder.onstop=downloadVideo;

        audioCtx=new (window.AudioContext||window.webkitAudioContext)();
        const source=audioCtx.createMediaStreamSource(stream);
        analyser=audioCtx.createAnalyser();
        analyser.fftSize=512;
        dataArray=new Uint8Array(analyser.frequencyBinCount);
        source.connect(analyser);

        document.getElementById('start').disabled=false;
        document.getElementById('stop').disabled=false;

        overlay.style.display='none'; // hide overlay after tap
        startFilter();
    }catch(err){
        alert('Camera/Microphone access failed: '+err);
    }
}

// Audio volume
function getVolume(){ if(!analyser) return 0; analyser.getByteFrequencyData(dataArray); let sum=0; for(let i=0;i<dataArray.length;i++) sum+=dataArray[i]; return (sum/dataArray.length)/255; }

// Blink
function updateBlink(){ const now=Date.now(); if(now-lastBlink>nextBlinkIn){ lastBlink=now; nextBlinkIn=2000+Math.random()*3000; blinkProgress=0; } blinkProgress=lerp(blinkProgress,1,0.12); return blinkProgress; }

// Main filter loop
async function startFilter(){
    async function loop(){
        const detections = await faceapi.detectSingleFace(video).withFaceLandmarks().withFaceExpressions();
        ctx.clearRect(0,0,canvas.width,canvas.height);

        ctx.save();
        ctx.translate(canvas.width,0); ctx.scale(-1,1); ctx.drawImage(video,0,0,canvas.width,canvas.height);
        ctx.restore();

        if(detections){
            const k=detections.landmarks.positions;
            const nose=k[30], leftCheek=k[2], rightCheek=k[14], mouthCenter=k[62], forehead=k[24], leftEye=k[36], rightEye=k[45];

            const smoothNoseX=lerp(prevNoseX,nose.x,0.3), smoothNoseY=lerp(prevNoseY,nose.y,0.3);
            prevNoseX=smoothNoseX; prevNoseY=smoothNoseY;

            const faceWidth=Math.abs(rightCheek.x-leftCheek.x);
            const maskWidth=faceWidth*1.4;
            const maskHeight=maskWidth*(catMask.height/Math.max(1,catMask.width));

            const toCanvasX=x=>canvas.width-(x/video.videoWidth)*canvas.width;
            const toCanvasY=y=>(y/video.videoHeight)*canvas.height;

            ctx.drawImage(catMask,toCanvasX(smoothNoseX)-maskWidth/2,toCanvasY(smoothNoseY)-maskHeight/2,maskWidth,maskHeight);

            const volume=getVolume();
            const mouthIndex=volume>0.05?Math.floor(Date.now()/150)%mouthFrames.length:0;
            const mouthImg=mouthFrames[mouthIndex];
            const mouthW=maskWidth*0.5;
            const mouthH=mouthW*(mouthImg.height/Math.max(1,mouthImg.width));
            ctx.drawImage(mouthImg,toCanvasX(mouthCenter.x)-mouthW/2,toCanvasY(mouthCenter.y)-mouthH/2+maskHeight*0.08,mouthW,mouthH);

            const earW=maskWidth*1.2, earH=earW*(ears.height/Math.max(1,ears.width));
            const sway=Math.sin(Date.now()/450)*earH*0.08;
            ctx.drawImage(ears,toCanvasX(forehead.x)-earW/2+sway,toCanvasY(forehead.y)-earH*0.9,earW,earH);

            const blink=updateBlink();
            const eyeW=maskWidth*0.28, eyeH=eyeW*(eyes.height/Math.max(1,eyes.width))*blink;
            ctx.drawImage(eyes,toCanvasX(leftEye.x)-eyeW/2,(toCanvasY(leftEye.y)+toCanvasY(rightEye.y))/2-eyeH/2,eyeW,eyeH);
            ctx.drawImage(eyes,toCanvasX(rightEye.x)-eyeW/2,(toCanvasY(leftEye.y)+toCanvasY(rightEye.y))/2-eyeH/2,eyeW,eyeH);
        }

        animationFrame=requestAnimationFrame(loop);
    }
    loop();
}

// Controls
document.getElementById('start').addEventListener('click',()=>{
    if(!mediaRecorder) return;
    if(!recording){ mediaRecorder.start(); recording=true; }
    else { mediaRecorder.state==='recording'?mediaRecorder.pause():mediaRecorder.resume(); }
});
document.getElementById('stop').addEventListener('click',()=>{
    if(recording) mediaRecorder.stop();
    recording=false;
    cancelAnimationFrame(animationFrame);
});

function downloadVideo(){
    const blob=new Blob(recordedChunks,{type:'video/webm'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='catface.webm'; document.body.appendChild(a); a.click(); a.remove();
    recordedChunks=[];
}

// Overlay tap triggers camera
overlay.addEventListener('click', ()=>{
    startCameraAndAudio();
});
</script>

</body>
</html>
